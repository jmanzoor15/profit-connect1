// src/index.ts
import { createUnplugin } from "unplugin";
import { resolve } from "pathe";
import { existsSync } from "fs";
import { parse } from "@vue/compiler-dom";
function getRootBlock(root, block) {
  return root.children.find((node) => node.type === 1 && node.tag === block);
}
function isSetupScript(node) {
  return node.props.some((prop) => prop.type === 6 && prop.name === "setup");
}
function langAttr(node) {
  var _a;
  if (!node)
    return "";
  const langProp = node.props.find(
    (prop) => prop.type === 6 && prop.name === "lang"
  );
  if (langProp && ((_a = langProp.value) == null ? void 0 : _a.content)) {
    return ` lang="${langProp.value.content}"`;
  }
  return "";
}
function injectProviderImport(code) {
  let root;
  try {
    root = parse(code);
  } catch (err) {
    console.warn("Failed to parse SFC:", code);
    console.error(err);
    return code;
  }
  const script = getRootBlock(root, "script");
  const importStatement = `import { FormKitLazyProvider } from '@formkit/vue'`;
  const setupScript = root.children.find(
    (node) => node.type === 1 && node.tag === "script" && isSetupScript(node)
  );
  if (!setupScript) {
    return `<script setup${langAttr(script)}>${importStatement}</script>
${code}`;
  }
  const startAt = setupScript.children[0].loc.start.offset;
  const before = code.substring(0, startAt);
  const after = code.substring(startAt);
  return `${before}
${importStatement}${after}`;
}
function injectProviderComponent(code, id, config, defaultConfig) {
  let root;
  try {
    root = parse(code);
  } catch (err) {
    console.warn("Failed to parse SFC:", code);
    console.error(err);
    return code;
  }
  const open = `<FormKitLazyProvider${config ? ' config-file="true"' : ""}${defaultConfig ? "" : ' :default-config="false"'}>`;
  const close = "</FormKitLazyProvider>";
  const template = getRootBlock(root, "template");
  if (!template) {
    console.warn(
      `To <template> block found in ${id}. Skipping FormKitLazyProvider injection.`
    );
    return code;
  }
  const before = code.substring(0, template.loc.start.offset + 10);
  const content = code.substring(
    template.loc.start.offset + 10,
    template.loc.end.offset - 11
  );
  const after = code.substring(template.loc.end.offset - 11);
  code = `${before}
${open}${content}${close}
${after}`;
  return code;
}
function resolveConfig(configFile) {
  const exts = ["ts", "mjs", "js"];
  const dir = configFile.startsWith(".") ? process.cwd() : "";
  let paths = [];
  if (exts.some((ext) => configFile.endsWith(ext))) {
    paths = [resolve(dir, configFile)];
  } else {
    paths = exts.map((ext) => resolve(dir, `${configFile}.${ext}`));
  }
  return paths.find((path) => existsSync(path));
}
var CONTAINS_FORMKIT_RE = /<FormKit|<form-kit/;
var FORMKIT_CONFIG_RE = /(\/\*\s?@__formkit\.config\.ts__\s?\*\/(?:.|\n)+?)\)/g;
var unpluginFactory = (options = {
  configFile: "./formkit.config",
  defaultConfig: true
}) => {
  const configPath = resolveConfig(options.configFile || "./formkit.config");
  return {
    name: "unplugin-formkit",
    enforce: "pre",
    // webpack's id filter is outside of loader logic,
    // an additional hook is needed for better perf on webpack
    transformInclude(id) {
      return true;
    },
    // just like rollup transform
    async transform(code, id) {
      if (configPath && FORMKIT_CONFIG_RE.test(code)) {
        code = code.replace(FORMKIT_CONFIG_RE, `"${configPath}")`);
        if (options.defaultConfig === false) {
          code = code.replace(
            /\/\* @__default-config__ \*\/(?:.|\n)+?\/\* @__default-config__ \*\//gi,
            ""
          );
        }
      }
      if (id.endsWith(".vue") && CONTAINS_FORMKIT_RE.test(code)) {
        code = injectProviderComponent(
          injectProviderImport(code),
          id,
          !!configPath,
          options.defaultConfig
        );
      }
      return code;
    }
  };
};
var unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);

export {
  unpluginFactory,
  unplugin
};
